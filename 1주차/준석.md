## 1장. 자바 8, 9, 10, 11: 무슨 일이 일어나고 있는가?

---

## 1. 왜 자바는 변화해야 했는가

### 프로그래밍 언어의 생존 법칙

프로그래밍 언어는 생태계와 같음. 새로운 언어가 등장하고 기존 언어는 도태됨. 코볼은 한때 비즈니스 로직 처리의 표준이었지만 지금은 레거시 시스템에서나 볼 수 있음. 델파이, 파스칼 같은 언어들도 마찬가지임.

자바도 위기를 느꼈음. 특히 JVM 위에서 동작하는 스칼라, 그루비, 코틀린 같은 언어들이 더 현대적인 기능을 제공하면서 자바의 입지를 위협함. 이들 언어는 함수형 프로그래밍, 타입 추론, 간결한 문법 등을 제공했고, 많은 개발자들이 자바의 장황함에 불만을 갖기 시작함.

### 하드웨어 환경의 변화

2000년대 중반까지 CPU 성능 향상은 클럭 속도를 높이는 방식이었음. 무어의 법칙에 따라 18개월마다 성능이 2배씩 향상됐고, 개발자들은 그저 기다리면 하드웨어가 프로그램을 빠르게 만들어줬음.

그러나 물리적 한계에 부딪혔음. 클럭 속도를 더 이상 높일 수 없게 되자 CPU 제조사들은 멀티코어 전략을 택함. 듀얼코어, 쿼드코어를 거쳐 이제는 8코어, 16코어가 일반화됨.

문제는 기존 자바 프로그램이 이런 멀티코어를 제대로 활용하지 못한다는 것임. 8코어 CPU에서 1개 코어만 100% 사용하고 나머지 7개는 대기 상태인 경우가 대부분이었음. 이는 8차선 고속도로에서 1차선만 사용하는 것과 같음.

### 빅데이터와 실시간 처리

또 다른 변화는 데이터의 폭발적 증가임. 소셜 미디어, IoT, 모바일 기기의 확산으로 처리해야 할 데이터가 기하급수적으로 늘어남. 페이스북은 하루에 수십 테라바이트의 데이터를 처리함.

이런 대용량 데이터를 처리하려면:

- 병렬 처리가 필수임
- 효율적인 메모리 관리가 필요함
- 간결하고 표현력 있는 코드가 필요함
- 실시간 스트림 처리 능력이 필요함

기존 자바의 명령형 프로그래밍 방식으로는 이런 요구사항을 충족하기 어려웠음.

---

## 2. 자바 8의 핵심 기능

### 람다 표현식 (Lambda Expression)

람다는 메서드를 하나의 식으로 표현한 것임. 익명 함수라고도 부름.

**왜 람다가 필요했나?**

자바는 객체지향 언어임. 모든 것이 객체여야 함. 심지어 함수조차도. 그래서 단순한 동작 하나를 전달하려면 클래스를 만들고, 객체를 생성하고, 메서드를 구현해야 했음.

예를 들어, 리스트를 정렬하는 간단한 작업을 보면:

```java
// Java 7
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

정작 중요한 코드는 `a1.getWeight().compareTo(a2.getWeight())` 한 줄인데, 이를 위해 5줄을 작성해야 함.

```java
// Java 8 람다
inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight()));
```

람다를 사용하면 1줄로 줄어듦. 코드가 무엇을 하는지 한눈에 보임.

**람다의 구조**

```java
(parameters) -> expression
(parameters) -> { statements; }
```

- 파라미터 리스트: 메서드의 파라미터
- 화살표: 람다의 파라미터와 바디를 구분
- 람다 바디: 표현식이나 구문

**람다 사용 예시**

```java
// 불린 표현식
(List<String> list) -> list.isEmpty()

// 객체 생성
() -> new Apple(10)

// 객체에서 소비
(Apple a) -> System.out.println(a.getWeight())

// 객체에서 선택/추출
(String s) -> s.length()

// 두 값을 조합
(int a, int b) -> a * b

// 두 객체 비교
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

### 메서드 참조 (Method Reference)

메서드 참조는 특정 메서드만을 호출하는 람다의 축약형임.

**왜 메서드 참조가 필요한가?**

람다가 하는 일이 기존 메서드를 호출하는 것뿐이라면, 메서드명을 직접 참조하는 것이 더 간결함.

```java
// 람다
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

// 메서드 참조
inventory.sort(comparing(Apple::getWeight));
```

**메서드 참조의 유형**

1. 정적 메서드 참조

```java
// 람다
(String s) -> Integer.parseInt(s)
// 메서드 참조
Integer::parseInt
```

2. 인스턴스 메서드 참조

```java
// 람다
(String s) -> s.toUpperCase()
// 메서드 참조
String::toUpperCase
```

3. 특정 객체의 인스턴스 메서드 참조

```java
Transaction expensiveTransaction = new Transaction();
// 람다
() -> expensiveTransaction.getValue()
// 메서드 참조
expensiveTransaction::getValue
```

4. 생성자 참조

```java
// 람다
() -> new Apple()
// 생성자 참조
Apple::new
```

메서드 참조를 사용하면 가독성이 더 좋아짐. `Apple::getWeight`는 "Apple의 getWeight 메서드"라는 의미가 명확함.

### 스트림 API (Stream API)

스트림은 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소임.

**스트림이 해결하는 문제**

기존 컬렉션 처리의 문제점:

1. 외부 반복: 사용자가 직접 요소를 반복함
2. 병렬 처리 어려움: 복잡한 스레드 코드가 필요함
3. 가독성이 떨어짐: 무엇을 하는지보다 어떻게 하는지에 집중함

**스트림의 특징**

1. **선언형**: 무엇을 할지만 명시함
2. **조립 가능**: 유연성이 향상됨
3. **병렬화**: 성능이 향상됨

**스트림 vs 컬렉션**

컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장함. 반면 스트림은 요청할 때만 요소를 계산함.

```java
// 컬렉션: 모든 요소가 메모리에 존재함
List<String> list = Arrays.asList("a", "b", "c");

// 스트림: 요소가 필요할 때만 계산함
Stream<String> stream = list.stream();
```

**스트림 연산**

스트림 연산은 두 그룹으로 나뉨:

1. 중간 연산: 스트림을 반환하며 여러 개 연결 가능함

   - `filter`: 조건에 맞는 요소를 선택함
   - `map`: 요소를 변환함
   - `limit`: 개수를 제한함
   - `sorted`: 정렬함
   - `distinct`: 중복을 제거함

2. 최종 연산: 스트림을 닫음
   - `forEach`: 각 요소에 작업을 수행함
   - `count`: 개수를 반환함
   - `collect`: 컬렉션으로 변환함

**스트림 사용 예시**

```java
// 거래 내역에서 2023년 거래를 거래액 순으로 정렬하고 거래 ID를 추출함
List<String> transactionIds =
    transactions.stream()
        .filter(t -> t.getYear() == 2023)
        .sorted(comparing(Transaction::getValue).reversed())
        .map(Transaction::getId)
        .collect(toList());
```

**병렬 스트림**

```java
// 순차 스트림
int sum = numbers.stream()
    .filter(n -> n % 2 == 0)
    .mapToInt(n -> n * n)
    .sum();

// 병렬 스트림 - parallelStream()만 추가함
int sum = numbers.parallelStream()
    .filter(n -> n % 2 == 0)
    .mapToInt(n -> n * n)
    .sum();
```

병렬 스트림은 내부적으로 fork/join 프레임워크를 사용함. 데이터를 여러 청크로 분할하고, 각 청크를 별도의 스레드에서 처리한 후 결과를 합침.

### 디폴트 메서드 (Default Method)

인터페이스가 구현을 가질 수 있게 됨.

**왜 디폴트 메서드가 필요한가?**

자바 8에서 Collection 인터페이스에 stream() 메서드를 추가하고 싶었음. 하지만 Collection을 구현하는 모든 클래스(ArrayList, HashSet 등 수백 개)가 stream()을 구현해야 함. 이는 하위 호환성을 깨뜨림.

**디폴트 메서드의 해결책**

```java
public interface Collection<E> extends Iterable<E> {
    // 추상 메서드들...

    // 디폴트 메서드
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
}
```

기존 구현체들은 자동으로 stream() 메서드를 상속받음. 필요하면 오버라이드할 수도 있음.

**다중 상속 문제**

디폴트 메서드로 인해 사실상 다중 상속이 가능해짐. 이로 인한 충돌 해결 규칙:

1. 클래스가 항상 우선임
2. 서브인터페이스가 우선임
3. 명시적으로 선택해야 함

```java
interface A {
    default void hello() { System.out.println("Hello from A"); }
}

interface B {
    default void hello() { System.out.println("Hello from B"); }
}

class C implements A, B {
    // 명시적으로 선택이 필요함
    public void hello() {
        A.super.hello(); // A의 메서드를 선택함
    }
}
```

---

## 3. 동작 파라미터화

동작 파라미터화는 아직 어떻게 실행할지 결정하지 않은 코드 블록을 의미함. 이 코드 블록은 나중에 프로그램에서 호출됨.

### 변화하는 요구사항

사과 필터링 예제를 보면 요구사항이 계속 바뀜:

1. 녹색 사과 필터링
2. 150g 이상 사과 필터링
3. 빨간 사과 필터링
4. 녹색이면서 150g 이상 필터링
   ...

### 값 파라미터화의 한계

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, String color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (apple.getColor().equals(color)) {
            result.add(apple);
        }
    }
    return result;
}

public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (apple.getWeight() > weight) {
            result.add(apple);
        }
    }
    return result;
}
```

코드 중복이 심함. DRY(Don't Repeat Yourself) 원칙을 위반함.

### 동작 파라미터화 적용

```java
public interface ApplePredicate {
    boolean test(Apple apple);
}

public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}
```

이제 다양한 동작을 전달할 수 있음:

```java
// 무거운 사과
filterApples(inventory, apple -> apple.getWeight() > 150);

// 녹색 사과
filterApples(inventory, apple -> "green".equals(apple.getColor()));

// 빨간색이면서 무거운 사과
filterApples(inventory, apple ->
    "red".equals(apple.getColor()) && apple.getWeight() > 150);
```

### 제네릭을 사용한 일반화

```java
public static <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> result = new ArrayList<>();
    for (T e : list) {
        if (p.test(e)) {
            result.add(e);
        }
    }
    return result;
}

// 사과 필터링
List<Apple> redApples = filter(inventory, apple -> "red".equals(apple.getColor()));

// 정수 필터링
List<Integer> evenNumbers = filter(numbers, i -> i % 2 == 0);

// 문자열 필터링
List<String> nonEmpty = filter(strings, s -> !s.isEmpty());
```

---

## 4. 함수형 프로그래밍

자바 8은 함수형 프로그래밍 패러다임을 도입함. 이는 객체지향과 상반된 개념이 아니라 보완하는 개념임.

### 함수형 프로그래밍의 핵심 개념

**일급 함수 (First-class Function)**

함수를 값으로 다룰 수 있음. 변수에 저장하고, 파라미터로 전달하고, 결과로 반환할 수 있음.

```java
// 함수를 변수에 저장함
Function<String, Integer> stringLength = String::length;

// 함수를 파라미터로 전달함
List<String> sorted = strings.sort(String::compareToIgnoreCase);

// 함수를 반환함
Function<Integer, Function<Integer, Integer>> add = x -> y -> x + y;
```

**순수 함수 (Pure Function)**

부작용이 없는 함수임. 같은 입력에 대해 항상 같은 출력을 반환함.

```java
// 순수 함수
public int add(int a, int b) {
    return a + b;  // 외부 상태 변경이 없음
}

// 순수하지 않은 함수
private int count = 0;
public int incrementAndGet() {
    return ++count;  // 외부 상태를 변경함
}
```

순수 함수의 장점:

- 테스트하기 쉬움
- 병렬 처리가 안전함
- 캐싱이 가능함
- 이해하기 쉬움

**불변성 (Immutability)**

데이터를 변경하지 않고 새로운 데이터를 생성함.

```java
// 가변 방식
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");

// 불변 방식
List<String> list = List.of("a", "b");
List<String> newList = Stream.concat(list.stream(), Stream.of("c"))
    .collect(toList());
```

**고차 함수 (Higher-order Function)**

함수를 인수로 받거나 함수를 반환하는 함수임.

```java
// Comparator.comparing은 고차 함수임
Comparator<Apple> c = Comparator.comparing(Apple::getWeight);

// 함수를 반환하는 함수
Function<String, Predicate<String>> startsWithLetter =
    letter -> name -> name.startsWith(letter);

Predicate<String> startsWithA = startsWithLetter.apply("A");
```

### 함수형 vs 명령형

**명령형 프로그래밍**

- 어떻게(How) 할 것인가에 집중함
- 상태 변경을 통한 계산을 함
- 제어 흐름(if, for, while)을 명시함

**함수형 프로그래밍**

- 무엇을(What) 할 것인가에 집중함
- 함수 조합을 통한 계산을 함
- 선언적으로 표현함

```java
// 명령형: 1부터 10까지 짝수의 제곱의 합
int sum = 0;
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        sum += i * i;
    }
}

// 함수형
int sum = IntStream.rangeClosed(1, 10)
    .filter(i -> i % 2 == 0)
    .map(i -> i * i)
    .sum();
```

---

## 6. 성능과 병렬화

### 병렬 스트림의 내부 동작

병렬 스트림은 내부적으로 ForkJoinPool을 사용함. 기본적으로 프로세서 수만큼의 스레드를 사용함.

```java
// 순차 처리
long sum = LongStream.rangeClosed(1, 1_000_000)
    .sum();

// 병렬 처리
long sum = LongStream.rangeClosed(1, 1_000_000)
    .parallel()
    .sum();
```

### 병렬화가 항상 빠른 것은 아님

병렬화에는 오버헤드가 있음:

- 스레드 생성 및 관리 비용이 발생함
- 데이터 분할 비용이 발생함
- 결과를 합치는 비용이 발생함

따라서 다음 경우에만 병렬화를 고려해야 함:

- 데이터가 충분히 클 때 (수천 개 이상)
- 연산이 복잡할 때
- 데이터 구조가 분할하기 쉬울 때 (ArrayList > LinkedList)

### 성능 측정 예제

```java
// 성능 측정 코드
public long measurePerf(Function<Long, Long> adder, long n) {
    long fastest = Long.MAX_VALUE;
    for (int i = 0; i < 10; i++) {
        long start = System.nanoTime();
        long sum = adder.apply(n);
        long duration = (System.nanoTime() - start) / 1_000_000;
        if (duration < fastest) fastest = duration;
    }
    return fastest;
}

// 순차 스트림
public long sequentialSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .reduce(0L, Long::sum);
}

// 병렬 스트림
public long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .parallel()
        .reduce(0L, Long::sum);
}
```

---

## 7. 자바 8이 가져온 변화

### 코드 품질 향상

**가독성**: 무엇을 하는지 명확히 드러남

```java
// Before
List<String> names = new ArrayList<>();
for (Person p : people) {
    if (p.getAge() >= 18) {
        names.add(p.getName());
    }
}

// After
List<String> names = people.stream()
    .filter(p -> p.getAge() >= 18)
    .map(Person::getName)
    .collect(toList());
```

**유지보수성**: 변경이 쉬움

```java
// 조건 추가가 쉬움
people.stream()
    .filter(p -> p.getAge() >= 18)
    .filter(p -> p.getCity().equals("Seoul"))  // 새 조건을 추가함
    .map(Person::getName)
    .collect(toList());
```

**테스트 용이성**: 각 연산을 독립적으로 테스트할 수 있음

### 생산성 향상

- 코드량 감소: 평균 50-80%가 감소함
- 버그 감소: 불변성과 순수 함수로 사이드 이펙트를 방지함
- 재사용성 증가: 함수 조합으로 새로운 기능을 구현함

### 현대적 프로그래밍

자바 8 이후 자바는 현대 언어들과 어깨를 나란히 할 수 있게 됨. 스칼라, 코틀린과 같은 JVM 언어들의 장점을 흡수하면서도 자바의 장점(생태계, 안정성, 성능)을 유지함.
