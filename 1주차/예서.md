# 1. 자바 8,9,10,11: 무슨 일이 일어나고 있는가?

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다. 자바 8에서 제공하는 새로운 기술을 간단하게 설명하면 다음과 같다.

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

## 왜 아직도 자바는 변화하는가

### 자바가 대중적인 프로그래밍 언어로 성장한 이유

1. 캡슐화
2. 객체지향
3. 코드를 JVM 바이트 코드로 컴파일 + 모든 브라우저에서 가상 머신 코드 지원

### 스트림 처리

- 스트림: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
- 자바 8에서 java.util.stream 패키지에 스트림 API 추가
- 스트림 API의 핵심
  - 기존에는 한 번에 한 항목을 처리했지만, 자바 8에서는 우리가 하려는 작업을 (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리
  - 스트림 파이프라인을 이용해 입력 부분을 CPU 코어에 쉽게 할당 가능 → 스레드라는 복잡한 작업을 사용하지 않으면서도 `공짜`로 병렬성을 얻을 수 있음


### 동작 파라미터화로 메서드에 코드 전달하기

- 코드의 일부를 API로 전달하는 기능
- 자바 8 이전에는 메서드를 다른 메서드로 전달할 방법 X
- 자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공하며, 이를 `동작 파라미터화` 라고 함
- 연산의 동작을 파라미터화할 수 있는 코드를 전달하기 때문에 중요

### 병렬성과 공유 가변 데이터

- ‘병렬성을 공짜로 얻을 수 있다’라는 말에서 시작된 개념
- 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 함
- 이러한 코드를 만들기 위해서는 공유된 가변 데이터에 접근하지 않아야 함
- 함수형 프로그래밍에서는 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 기능을 제공

## 자바 함수

- 프로그래밍 언어에서 함수
  - 메서드, 정적 메서드와 같은 의미로 사용
- 자바의 함수
  - 메서드 + 수학적인 함수처럼 사용
  - 부작용을 일으키지 않는 함수

프로그래밍 언어의 핵심은 값을 바꾸는 것인데 메서드는 그 자체로 값이 될 수 없음. 따라서 자바 8 설계자들은 메서드를 값으로 취급할 수 있게 제공

### 메서드와 람다

- **메서드 참조**
  - 메서드 참조라는 자바 8의 새로운 기능을 통해 메서드를 값으로 사용 가능
- **람다 : 익명함수**
  - 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급 가능

### 코드 예제
- 사과들이 여러 개 있을 때, 모든 녹색 사과를 선택해서 리스트를 반환하는 프로그램

**자바 8 이전**

```java
/**
* 자바 8 이전
* 사과 색깔이 초록색인 것만 필터링해 반환
*/
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for (Apple apple : inventory) {
        if ("green".equals(apple.getColor())) {
            result.add(apple);
        }
    }
    return result;
}

/**
* 자바 8 이전
* 사과 무게가 150그램 이상인 것만 필터링해 반환
*/
public static List<Apple> filterHeavyApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();

    for (Apple apple : inventory) {
        if (apple.getWeight() > 150) {
            result.add(apple);
        }
    }
    return result;
}
```

- 만약 사과를 무게로 필터링하고 싶다면, 똑같은 코드를 복사&붙여넣기 하여 다음과 같은 코드를 구현해야 함
- 두 메서드는 if문의 조건을 제외하면 완전히 내용이 동일. 여기서 다른 조건으로 사과를 필터링하는 요구사항이 생긴다면 계속해서 중복된 코드 발생

**자바 8 이후**

```java
/**
 * 자바 8 이후 사과 색깔이 초록색인 것만 필터링해 반환
 */
public static boolean isGreenApple(Apple apple) {
    return "green".equals(apple.getColor());
}

/**
 * 자바 8 이후 사과 무게가 150그램 이상인 것만 필터링해 반환
 */
public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

public interface Predicate<T>{
    boolean test(T t);

}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}
```

```java
// 메서드 호출
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```

- 자바 8에서는 다음처럼 메서드를 값으로 전달 가능

> **프레디케이트(predicate)란?**
> 
> 예제에서 Apple::isGreenApple 메서드를 filterApples로 넘겨주었다. 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트라고 한다.
>

### 메서드 전달에서 람다로

- 메서드를 값으로 전달하는 것은 유용한 기능
- 하지만 한두 번만 사용할 메서드를 매번 정의하는 것은 불편
- 자바 8에서는 람다라는 새로운 개념을 이용해 이를 해결

```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```

- 이처럼 한번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.

## 스트림

- 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리 가능, 병렬처리 지원
- 스트림 API는 컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, 멀티코어 활용 어려움이라는 두 가지 문제를 모두 해결
- 컬렉션: 어떻게 데이터를 저장하고 접근할지에 중점
- 스트림: 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점

## 디폴트 메서드

- 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가 가능
- 이를 디폴트 메서드라고 부름
- 디폴트 메서드를 통해 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있음
- 인터페이스 규격 명세에 `defalut`라는 새로운 키워드를 지원

## 💡정리
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 기능을 제공
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어려움
- 함수는 일급값이다. 메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지 기억
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있음
