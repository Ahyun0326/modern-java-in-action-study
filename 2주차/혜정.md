# 2. 동작 파라미터화 코드 전달하기

## 1. 동작 파라미터화란?
- **동작(behavior)을 메서드의 인자로 전달하는 기법**
- 상황에 따라 달라지는 조건이나 로직을 **파라미터로 전달**해 유연하게 코드를 작성할 수 있음
- 예: 사과 필터링 시 색깔, 무게, 조건을 코드로 직접 전달하지 않고 **조건을 추상화**해서 전달


## 2. 동작 파라미터화의 필요성
- if/else, switch 문으로 분기하는 코드 → **변경이 생길 때마다 코드 수정 필요**
- 동작 파라미터화를 이용하면 → **코드 재사용성, 유지보수성** 증가


## 3. 전략 패턴 (Strategy Pattern)
- 동작 파라미터화를 구현하는 대표적인 방식
- **조건을 캡슐화**한 인터페이스를 정의하고, 다양한 구현 클래스를 만들어 전략적으로 교체 가능

```java
public interface ApplePredicate {  
    boolean test(Apple apple);  
}  

public class AppleHeavyWeightPredicate implements ApplePredicate {  
    public boolean test(Apple apple) {  
        return apple.getWeight() > 150;  
    }  
}  

public class AppleGreenColorPredicate implements ApplePredicate {  
    public boolean test(Apple apple) {  
        return "green".equals(apple.getColor());  
    }  
}
``` 

- 사용 예시:
```java
List<Apple> result = filterApples(inventory, new AppleGreenColorPredicate());  
```


## 4. 익명 클래스 사용
- 불필요하게 클래스를 계속 만드는 문제를 해결하기 위해 **익명 클래스** 사용 가능

```java
List<Apple> redApples = filterApples(inventory, new ApplePredicate() {  
    public boolean test(Apple apple) {  
        return "red".equals(apple.getColor());  
    }  
});
```


## 5. 람다 표현식 사용
- Java 8부터는 **람다**로 간단하게 동작 전달 가능
- 익명 클래스보다 훨씬 간결

```java
List<Apple> redApples = filterApples(inventory, (Apple a) -> "red".equals(a.getColor()));  
```


## 6. 리스트 형식으로 추상화하기
- Apple에만 국한되지 않고, **제네릭 메서드**로 확장 가능

```java
public static <T> List<T> filter(List<T> list, Predicate<T> p) {  
    List<T> result = new ArrayList<>();  
    for (T e : list) {  
        if (p.test(e)) {  
            result.add(e);  
        }  
    }  
    return result;  
}
```

- 사용 예시:
```java
List<String> strings = filter(listOfStrings, s -> !s.isEmpty());
```


