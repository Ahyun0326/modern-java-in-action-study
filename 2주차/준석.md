## 3장. 람다 표현식 (3.1 - 3.5)

---

## 3.1 람다란 무엇인가?

### 람다 표현식이 필요한 이유

자바는 객체지향 언어임. 모든 것이 객체여야 함. 단순한 동작 하나를 전달하려면 클래스를 만들고, 객체를 생성하고, 메서드를 구현해야 했음. 이는 너무 번거롭고 코드가 장황해짐.

```java
// Java 7 - 익명 클래스를 사용한 방식
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

정작 중요한 코드는 `a1.getWeight().compareTo(a2.getWeight())` 한 줄인데, 이를 위해 5줄을 작성해야 함.

### 람다 표현식의 특징

**익명**: 메서드 이름이 없음
**함수**: 특정 클래스에 종속되지 않음  
**전달**: 메서드 인수로 전달하거나 변수로 저장 가능
**간결성**: 익명 클래스처럼 많은 코드를 구현할 필요 없음

### 람다의 구조

```java
(parameters) -> expression
(parameters) -> { statements; }
```

람다는 크게 세 부분으로 구성됨:

- **파라미터 리스트**: 메서드의 파라미터
- **화살표(->)**: 람다의 파라미터와 바디를 구분
- **람다 바디**: 표현식이나 구문 (람다의 반환값에 해당)

### 람다 표현식 예시

```java
// 불린 표현식
(List<String> list) -> list.isEmpty()

// 객체 생성
() -> new Apple(10)

// 객체에서 소비
(Apple a) -> System.out.println(a.getWeight())

// 객체에서 선택/추출
(String s) -> s.length()

// 두 값을 조합
(int a, int b) -> a * b

// 두 객체 비교
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

---

## 3.2 어디에, 어떻게 람다를 사용할까?

### 함수형 인터페이스

람다 표현식은 **함수형 인터페이스**라는 문맥에서만 사용할 수 있음.

**함수형 인터페이스란?**

- 정확히 하나의 추상 메서드를 지정하는 인터페이스
- @FunctionalInterface 애노테이션으로 명시 가능
- Single Abstract Method(SAM)라고도 불림

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

### 람다와 함수형 인터페이스

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있음. 전체 표현식을 함수형 인터페이스의 인스턴스로 취급함.

```java
// 익명 클래스 사용
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello World");
    }
};

// 람다 표현식 사용
Runnable r2 = () -> System.out.println("Hello World");

// 람다 표현식 직접 전달
process(() -> System.out.println("Hello World"));
```

### 함수 디스크립터

함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킴. 이를 **함수 디스크립터**라고 부름.

예시:

- `() -> void` : Runnable
- `T -> boolean` : Predicate<T>
- `T -> void` : Consumer<T>

---

## 3.3 람다 활용: 실행 어라운드 패턴

실행 어라운드 패턴은 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 가짐.

### 기존의 제한된 코드

```java
public String processFile() throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return br.readLine();  // 한 줄만 읽을 수 있음
    }
}
```

### 동작 파라미터화 적용

```java
// 1단계: 함수형 인터페이스 정의
@FunctionalInterface
public interface BufferedReaderProcessor {
    String process(BufferedReader b) throws IOException;
}

// 2단계: 동작을 파라미터로 전달
public String processFile(BufferedReaderProcessor p) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return p.process(br);  // 동작 실행
    }
}

// 3단계: 람다 전달
// 한 줄 읽기
String oneLine = processFile((BufferedReader br) -> br.readLine());

// 두 줄 읽기
String twoLines = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

실행 어라운드 패턴을 람다와 활용하면 유연성과 재사용성을 추가로 얻을 수 있음.

---

## 3.4 함수형 인터페이스 사용

자바 8은 `java.util.function` 패키지에 여러 가지 새로운 함수형 인터페이스를 제공함.

### Predicate<T>

`test`라는 추상 메서드를 정의하며 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환함.

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}

// 사용 예시
public <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> results = new ArrayList<>();
    for (T t : list) {
        if (p.test(t)) {
            results.add(t);
        }
    }
    return results;
}

// 빈 문자열이 아닌 것만 필터링
Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```

### Consumer<T>

제네릭 형식 T 객체를 받아서 void를 반환하는 `accept` 추상 메서드를 정의함. T 형식의 객체를 인수로 받아 어떤 동작을 수행하고 싶을 때 사용함.

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}

// 사용 예시
public <T> void forEach(List<T> list, Consumer<T> c) {
    for (T t : list) {
        c.accept(t);
    }
}

// 각 요소를 출력
forEach(Arrays.asList(1, 2, 3, 4, 5), (Integer i) -> System.out.println(i));
```

### Function<T, R>

제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 `apply`를 정의함. 입력을 출력으로 매핑하는 람다를 정의할 때 사용함.

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

// 사용 예시
public <T, R> List<R> map(List<T> list, Function<T, R> f) {
    List<R> result = new ArrayList<>();
    for (T t : list) {
        result.add(f.apply(t));
    }
    return result;
}

// 문자열 리스트의 각 요소 길이를 반환
List<Integer> lengths = map(Arrays.asList("lambdas", "in", "action"),
                            (String s) -> s.length());
```

### 기본형 특화

자바의 모든 형식은 참조형 또는 기본형에 해당함. 제네릭 파라미터에는 참조형만 사용할 수 있음.

박싱(Boxing): 기본형 → 참조형
언박싱(Unboxing): 참조형 → 기본형
오토박싱(Autoboxing): 자동 변환

박싱된 값은 메모리를 더 소비하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요함.

자바 8은 오토박싱을 피할 수 있도록 특별한 버전의 함수형 인터페이스를 제공함:

```java
// 기본형 특화 인터페이스
IntPredicate evenNumbers = (int i) -> i % 2 == 0;
evenNumbers.test(1000);  // 박싱 없음

// 일반 Predicate는 박싱이 필요함
Predicate<Integer> oddNumbers = (Integer i) -> i % 2 != 0;
oddNumbers.test(1000);  // 박싱 발생
```

---

## 3.5 형식 검사, 형식 추론, 제약

### 형식 검사

람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있음. 어떤 콘텍스트에서 기대되는 람다 표현식의 형식을 **대상 형식(target type)**이라고 부름.

형식 검사 과정:

1. 람다가 사용된 메서드의 선언을 확인함
2. 메서드의 파라미터로 대상 형식을 기대함
3. 대상 형식의 함수 디스크립터를 확인함
4. 람다의 시그니처와 대상 형식이 일치하는지 확인함

```java
// filter 메서드 예시
filter(inventory, (Apple apple) -> apple.getWeight() > 150);

// 1. filter 메서드 선언 확인
// 2. 두 번째 파라미터로 Predicate<Apple> 형식 기대
// 3. Predicate<Apple>은 Apple -> boolean 함수 디스크립터
// 4. 람다도 Apple -> boolean이므로 형식 검사 성공
```

### 같은 람다, 다른 함수형 인터페이스

대상 형식이라는 특징 때문에 같은 람다 표현식이어도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있음.

```java
Comparator<Apple> c1 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
ToIntBiFunction<Apple, Apple> c2 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
BiFunction<Apple, Apple, Integer> c3 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

### 형식 추론

자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론함. 따라서 람다 파라미터의 형식을 생략할 수 있음.

```java
// 형식을 명시한 람다
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 형식 추론을 이용한 람다
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

### 지역 변수 사용

람다 표현식에서는 익명 함수가 하는 것처럼 **자유 변수**(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용할 수 있음. 이를 **람다 캡처링**이라고 부름.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```

### 지역 변수의 제약

람다에서 참고하는 지역 변수는 final로 선언되거나 실질적으로 final처럼 취급되어야 함.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 31337;  // 컴파일 에러! 람다에서 참조하는 지역 변수는 final이어야 함
```

**제약의 이유**

인스턴스 변수와 지역 변수는 태생부터 다름:

- 인스턴스 변수: 힙에 저장됨
- 지역 변수: 스택에 저장됨

람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있음. 따라서 자바는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공함.

### 클로저

클로저란 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스를 가리킴. 자바 8의 람다와 익명 클래스는 클로저와 비슷한 동작을 수행함.

람다와 익명 클래스 모두 메서드의 인수로 전달될 수 있고, 자신의 외부 영역의 변수에 접근할 수 있음. 단, 람다가 정의된 메서드의 지역 변수값은 final이어야 함. 덕분에 람다는 변수가 아닌 값에 국한되어 어떤 동작을 수행한다는 사실이 명확해짐.

---

## 정리

자바 8이 람다 표현식을 도입한 이유는 코드를 더 간결하고 유연하게 만들기 위해서임. 함수형 인터페이스와 함께 사용하면 동작을 파라미터화하고 코드를 재사용할 수 있음.

특히 실행 어라운드 패턴처럼 자원 처리 로직을 감싸는 코드에서 람다를 사용하면 핵심 로직만 간단히 전달할 수 있음. 자바가 제공하는 Predicate, Consumer, Function 같은 함수형 인터페이스를 활용하면 대부분의 상황을 해결할 수 있음.

형식 검사와 형식 추론을 통해 컴파일러가 람다의 타입을 자동으로 파악하므로 코드가 더 간결해짐. 다만 지역 변수 사용 시 final 제약이 있다는 점을 기억해야 함.
